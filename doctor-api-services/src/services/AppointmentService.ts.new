import { IAppointment, Appointment } from '../models/Appointment';
import GoogleCalendarService from './google/calendar';
import moment from 'moment-timezone';
import config from '../config';

interface TimeSlot {
  time: string;
  displayTime: string;
  displayDate: string;
  period: 'ma√±ana' | 'tarde';
  status: 'disponible' | 'ocupado';
}

export class AppointmentService {
    private googleCalendar: GoogleCalendarService;
    private workingHours = {
        start: 9, // 9 AM
        end: 17, // 5 PM
        duration: 30 // duraci√≥n de la cita en minutos
    };

    constructor() {
        this.googleCalendar = new GoogleCalendarService();
        moment.locale('es');
    }

    async getAvailableSlots(date: string) {
        try {
            // Convertir la fecha a la zona horaria correcta
            const timezone = config.google.timezone;
            const startOfDay = moment.tz(date, timezone).startOf('day');
            const endOfDay = moment.tz(date, timezone).endOf('day');
            
            // Obtener citas existentes
            const existingAppointments = await this.googleCalendar.listEvents(
                startOfDay.toDate(),
                endOfDay.toDate()
            );
            
            // Generar todos los slots posibles
            const slots = [];
            const currentMoment = moment();
            
            for (let hour = this.workingHours.start; hour < this.workingHours.end; hour++) {
                for (let minute = 0; minute < 60; minute += this.workingHours.duration) {
                    const slotTime = moment.tz(date, timezone)
                        .hour(hour)
                        .minute(minute)
                        .second(0)
                        .millisecond(0);
                    
                    // No agregar slots en el pasado
                    if (slotTime.isBefore(currentMoment)) {
                        continue;
                    }

                    // Verificar disponibilidad
                    const isBooked = existingAppointments.some(event => 
                        moment(event.start?.dateTime).isSame(slotTime)
                    );

                    if (!isBooked) {
                        slots.push({
                            time: slotTime.toISOString(),
                            displayTime: slotTime.format('HH:mm'),
                            displayDate: slotTime.format('D [de] MMMM [de] YYYY'),
                            period: hour < 13 ? 'ma√±ana' : 'tarde',
                            status: 'disponible'
                        });
                    }
                }
            }

            return { success: true, data: slots };
        } catch (error) {
            console.error('Error en getAvailableSlots:', error);
            throw error;
        }
    }

    async getAppointments(date?: string, status?: string) {
        try {
            let query: any = {};
            
            if (date) {
                const startOfDay = moment.tz(date, config.google.timezone).startOf('day');
                const endOfDay = moment.tz(date, config.google.timezone).endOf('day');
                
                query.createdAt = {
                    $gte: startOfDay.toDate(),
                    $lte: endOfDay.toDate()
                };
            }
            
            if (status) {
                query.status = status;
            }

            const appointments = await Appointment.find(query)
                .sort({ date: 1, time: 1 })
                .lean();

            return appointments;
        } catch (error) {
            console.error('Error en getAppointments:', error);
            throw error;
        }
    }

    async getAppointmentById(id: string) {
        try {
            const appointment = await Appointment.findById(id).lean();
            return appointment;
        } catch (error) {
            console.error('Error en getAppointmentById:', error);
            throw error;
        }
    }

    async createAppointment(appointmentData: IAppointment) {
        try {
            // Validar que el horario est√© disponible
            const appointmentTime = moment.tz(
                `${appointmentData.date} ${appointmentData.time}`,
                'YYYY-MM-DD HH:mm',
                config.google.timezone
            );

            const slots = await this.getAvailableSlots(appointmentData.date);
            const isSlotAvailable = slots.data.some(slot => 
                moment(slot.time).isSame(appointmentTime)
            );

            if (!isSlotAvailable) {
                throw new Error('El horario seleccionado no est√° disponible');
            }

            // Crear evento en Google Calendar
            const eventData = {
                summary: `Consulta: ${appointmentData.clientName}`,
                description: `
üè• Consulta M√©dica
------------------
üë§ Paciente: ${appointmentData.clientName}
üìû Tel√©fono: ${appointmentData.phone}
${appointmentData.email ? `üìß Email: ${appointmentData.email}` : ''}
${appointmentData.socialWork ? `üè• Obra Social: ${appointmentData.socialWork}` : ''}
${appointmentData.description ? `\nüìù Notas:\n${appointmentData.description}` : ''}`,
                start: {
                    dateTime: appointmentTime.toISOString(),
                    timeZone: config.google.timezone
                },
                end: {
                    dateTime: appointmentTime.add(this.workingHours.duration, 'minutes').toISOString(),
                    timeZone: config.google.timezone
                }
            };

            const event = await this.googleCalendar.createEvent(eventData);
            
            // Crear cita en MongoDB
            const appointment = new Appointment({
                ...appointmentData,
                eventId: event.id,
                status: 'pending'
            });

            await appointment.save();
            return appointment;
        } catch (error) {
            console.error('Error en createAppointment:', error);
            throw error;
        }
    }

    async updateAppointment(id: string, updateData: Partial<IAppointment>) {
        try {
            const appointment = await Appointment.findById(id);
            
            if (!appointment) {
                throw new Error('Cita no encontrada');
            }

            // Si se est√° actualizando la fecha/hora, validar disponibilidad
            if (updateData.date || updateData.time) {
                const newDate = updateData.date || appointment.date;
                const newTime = updateData.time || appointment.time;
                
                const appointmentTime = moment.tz(
                    `${newDate} ${newTime}`,
                    'YYYY-MM-DD HH:mm',
                    config.google.timezone
                );

                const slots = await this.getAvailableSlots(newDate);
                const isSlotAvailable = slots.data.some(slot => 
                    moment(slot.time).isSame(appointmentTime)
                );

                if (!isSlotAvailable) {
                    throw new Error('El nuevo horario seleccionado no est√° disponible');
                }
            }

            // Actualizar evento en Google Calendar
            if (appointment.eventId) {
                const eventData = {
                    summary: `Consulta: ${updateData.clientName || appointment.clientName}`,
                    description: `
üè• Consulta M√©dica
------------------
üë§ Paciente: ${updateData.clientName || appointment.clientName}
üìû Tel√©fono: ${updateData.phone || appointment.phone}
${updateData.email || appointment.email ? `üìß Email: ${updateData.email || appointment.email}` : ''}
${updateData.socialWork || appointment.socialWork ? `üè• Obra Social: ${updateData.socialWork || appointment.socialWork}` : ''}
${updateData.description || appointment.description ? `\nüìù Notas:\n${updateData.description || appointment.description}` : ''}`,
                    start: {
                        dateTime: moment.tz(
                            `${updateData.date || appointment.date} ${updateData.time || appointment.time}`,
                            'YYYY-MM-DD HH:mm',
                            config.google.timezone
                        ).toISOString(),
                        timeZone: config.google.timezone
                    },
                    end: {
                        dateTime: moment.tz(
                            `${updateData.date || appointment.date} ${updateData.time || appointment.time}`,
                            'YYYY-MM-DD HH:mm',
                            config.google.timezone
                        ).add(this.workingHours.duration, 'minutes').toISOString(),
                        timeZone: config.google.timezone
                    }
                };

                await this.googleCalendar.updateEvent(appointment.eventId, eventData);
            }

            // Actualizar cita en MongoDB
            Object.assign(appointment, updateData);
            await appointment.save();
            
            return appointment;
        } catch (error) {
            console.error('Error en updateAppointment:', error);
            throw error;
        }
    }

    async deleteAppointment(id: string) {
        try {
            const appointment = await Appointment.findById(id);
            
            if (!appointment) {
                throw new Error('Cita no encontrada');
            }

            // Eliminar evento de Google Calendar
            if (appointment.eventId) {
                await this.googleCalendar.deleteEvent(appointment.eventId);
            }

            // Eliminar cita de MongoDB
            await appointment.deleteOne();
            
            return true;
        } catch (error) {
            console.error('Error en deleteAppointment:', error);
            throw error;
        }
    }
}
